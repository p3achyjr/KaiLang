use kai_ast::ast::{
  Function,
  FuncArg,
  Stmt,
  Expr,
  Type,
};
use kai_common_types::ops::Opcode;

grammar;

// MACROS

Comma<T>: Vec<T> = {
  <v:(<T> ",")*> <e:T?> => match e {
      None => v,
      Some(e) => {
          let mut v = v;
          v.push(e);
          v
      }
  }
};

// END MACROS

pub Function: Function = {
  "function" <i:Ident> <fa:FuncArgs> ":" <ret_ty:Type> <b:Block> => 
    Function {
      ident: i,
      args: fa,
      body: b,
      ret_ty: ret_ty,
    },
};

FuncArgs: Vec<FuncArg> = {
  "(" <al:FuncArgList> ")" => al,
};

FuncArgList = Comma<FuncArg>;

FuncArg: FuncArg = {
  <i:Ident> ":" <t:Type> => FuncArg {ty: t, ident: i},
};

Block: Vec<Stmt> = {
  "{" <sl:StmtList> "}" => sl,
};

StmtList: Vec<Stmt> = {
  () => vec![],
  <l:StmtList> <s:StmtWrapper> => (| | {let mut l = l; l.push(s); l})(),
};

StmtWrapper: Stmt = {
  <s:Stmt> ";" => s,
};

Stmt: Stmt = {
  "let" <i:Ident> "=" <e:Expr> => Stmt::VarDecl(i, *e),
  <i:Ident> "=" <e:Expr> => Stmt::VarAsgn(i, *e),

  "return" <e:Expr> => Stmt::Return(*e),
};

Expr: Box<Expr> = {
  <l: Expr> <o: OrOp> <r: AndT> => Box::new(Expr::Binop(o, l, r)),
  AndT,
};

OrOp: Opcode = {
  "||" => Opcode::LogOr,
};

AndT: Box<Expr> = {
  <l: AndT> <o: AndOp> <r: EqT> => Box::new(Expr::Binop(o, l, r)),
  EqT,
};

AndOp: Opcode = {
  "&&" => Opcode::LogAnd,
};

EqT: Box<Expr> = {
  <l: EqT> <o: EqOp> <r: CmpT> => Box::new(Expr::Binop(o, l, r)),
  CmpT,
};

EqOp: Opcode = {
  "==" => Opcode::LogEq,
  "!=" => Opcode::LogNeq,
};

CmpT: Box<Expr> = {
  <l: CmpT> <o: CmpOp> <r: Arith> => Box::new(Expr::Binop(o, l, r)),
  Arith,
};

CmpOp: Opcode = {
  "<" => Opcode::Lt,
  "<=" => Opcode::Leq,
  ">" => Opcode::Gt,
  ">=" => Opcode::Geq,
};

Arith: Box<Expr> = {
  <l:Arith> <o:ArithOp> <r:Factor> => Box::new(Expr::Binop(o, l, r)),
  Factor,
};

ArithOp: Opcode = {
  "+" => Opcode::Add,
  "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
  <l:Factor> <o:FactorOp> <r:Term> => Box::new(Expr::Binop(o, l, r)),
  Term,
};

FactorOp: Opcode = {
  "*" => Opcode::Mul,
  "/" => Opcode::Div,
  "%" => Opcode::Mod,
};

Term: Box<Expr> = {
  <b:Bool> => Box::new(Expr::Bool(b)),
  Num => Box::new(Expr::Num(<>)),
  Ident => Box::new(Expr::Ident(<>)),
  "(" <e:Expr> ")" => e,
};

Type: Type = {
  "int" => Type::Int,
  "bool" => Type::Bool,
};

Bool: bool = {
  "true" => true,
  "false" => false,
};
Num: i32 = <s:r"[0-9]+"> => s.to_string().parse::<i32>().unwrap();
Ident: String = <s:r"[a-zA-Z_]+\w*"> => s.to_string();
